'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var index_js = require('buffer/index.js');

var x=t=>(index_js.Buffer.isBuffer(t)?t:index_js.Buffer.from(t)).toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,""),j={encryption:{saltBits:256,algorithm:"aes-256-cbc",iterations:1,minPasswordlength:32},integrity:{saltBits:256,algorithm:"sha256",iterations:1,minPasswordlength:32},ttl:0,timestampSkewSec:60,localtimeOffsetMsec:0},v=t=>({...t,encryption:{...t.encryption},integrity:{...t.integrity}}),h={"aes-128-ctr":{keyBits:128,ivBits:128,name:"AES-CTR"},"aes-256-cbc":{keyBits:256,ivBits:128,name:"AES-CBC"},sha256:{keyBits:256,name:"SHA-256"}},A="2",K=`Fe26.${A}`,M=(t,n)=>{let e=index_js.Buffer.allocUnsafe(n);return t.getRandomValues(e),e},b=(t,n)=>{if(n<1)throw Error("Invalid random bits count");let e=Math.ceil(n/8);return M(t,e)},H=async(t,n,e,s,r,c)=>{let o=new TextEncoder,a=o.encode(n),i=await t.subtle.importKey("raw",a,"PBKDF2",!1,["deriveBits"]),m=o.encode(e),f={name:"PBKDF2",hash:c,salt:m,iterations:s},y=await t.subtle.deriveBits(f,i,r*8);return index_js.Buffer.from(y)},E=async(t,n,e)=>{if(n==null||!n.length)throw new Error("Empty password");if(e==null||typeof e!="object")throw new Error("Bad options");if(!(e.algorithm in h))throw new Error(`Unknown algorithm: ${e.algorithm}`);let s=h[e.algorithm],r={},c=e.hmac??!1,o=c?{name:"HMAC",hash:s.name}:{name:s.name},a=c?["sign","verify"]:["encrypt","decrypt"];if(typeof n=="string"){if(n.length<e.minPasswordlength)throw new Error(`Password string too short (min ${e.minPasswordlength} characters required)`);let{salt:i=""}=e;if(!i){let{saltBits:y=0}=e;if(!y)throw new Error("Missing salt and saltBits options");i=b(t,y).toString("hex");}let m=await H(t,n,i,e.iterations,s.keyBits/8,"SHA-1"),f=await t.subtle.importKey("raw",m,o,!1,a);r.key=f,r.salt=i;}else {if(n.length<s.keyBits/8)throw new Error("Key buffer (password) too small");r.key=await t.subtle.importKey("raw",n,o,!1,a),r.salt="";}return e.iv?r.iv=e.iv:"ivBits"in s&&(r.iv=b(t,s.ivBits)),r},I=async(t,n,e,s)=>{let r=await E(t,n,e),o=new TextEncoder().encode(s),a=await t.subtle.encrypt({name:h[e.algorithm].name,iv:r.iv},r.key,o);return {encrypted:index_js.Buffer.from(a),key:r}},R=async(t,n,e,s)=>{let r=await E(t,n,e),c=await t.subtle.decrypt({name:h[e.algorithm].name,iv:r.iv},r.key,index_js.Buffer.isBuffer(s)?s:index_js.Buffer.from(s));return new TextDecoder().decode(c)},k=async(t,n,e,s)=>{let r=await E(t,n,{...e,hmac:!0}),o=new TextEncoder().encode(s),a=await t.subtle.sign({name:"HMAC"},r.key,o);return {digest:x(index_js.Buffer.from(a)),salt:r.salt}},$=t=>typeof t=="object"&&!index_js.Buffer.isBuffer(t)?"secret"in t?{id:t.id,encryption:t.secret,integrity:t.secret}:{id:t.id,encryption:t.encryption,integrity:t.integrity}:{encryption:t,integrity:t},F=async(t,n,e,s)=>{if(!e)throw Error("Empty password");let r=v(s),c=Date.now()+(r.localtimeOffsetMsec||0),o=JSON.stringify(n),a=$(e),{id:i=""}=a;if(i&&!/^\w+$/.test(i))throw new Error("Invalid password id");let{encrypted:m,key:f}=await I(t,a.encryption,r.encryption,o),y=x(m),d=x(f.iv),u=r.ttl?c+r.ttl:"",w=`${K}*${i}*${f.salt}*${d}*${y}*${u}`,g=await k(t,a.integrity,r.integrity,w);return `${w}*${g.salt}*${g.digest}`},D=(t,n)=>{let e=t.length===n.length?0:1;e&&(n=t);for(let s=0;s<t.length;s+=1)e|=t.charCodeAt(s)^n.charCodeAt(s);return e===0},U=async(t,n,e,s)=>{if(!e)throw Error("Empty password");let r=v(s),c=Date.now()+(r.localtimeOffsetMsec||0),o=n.split("*");if(o.length!==8)throw new Error("Incorrect number of sealed components");let a=o[0],i=o[1],m=o[2],f=o[3],y=o[4],d=o[5],u=o[6],w=o[7],g=`${a}*${i}*${m}*${f}*${y}*${d}`;if(K!==a)throw new Error("Wrong mac prefix");if(d){if(!/^\d+$/.exec(d))throw new Error("Invalid expiration");if(parseInt(d,10)<=c-r.timestampSkewSec*1e3)throw new Error("Expired seal")}if(typeof e>"u"||typeof e=="string"&&e.length===0)throw new Error("Empty password");let p;if(typeof e=="object"&&!index_js.Buffer.isBuffer(e)){if(!((i||"default")in e))throw new Error(`Cannot find password: ${i}`);p=e[i||"default"];}else p=e;p=$(p);let P=r.integrity;P.salt=u;let O=await k(t,p.integrity,P,g);if(!D(O.digest,w))throw new Error("Bad hmac value");let C=index_js.Buffer.from(y,"base64"),B=r.encryption;B.salt=m,B.iv=index_js.Buffer.from(f,"base64");let S=await R(t,p.encryption,B,C);return S?JSON.parse(S):null};

Object.defineProperty(exports, 'Buffer', {
	enumerable: true,
	get: function () { return index_js.Buffer; }
});
exports.algorithms = h;
exports.base64urlEncode = x;
exports.clone = v;
exports.decrypt = R;
exports.defaults = j;
exports.encrypt = I;
exports.generateKey = E;
exports.hmacWithPassword = k;
exports.macFormatVersion = A;
exports.macPrefix = K;
exports.randomBits = b;
exports.seal = F;
exports.unseal = U;
